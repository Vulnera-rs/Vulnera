# Rust Memory Safety & Unwrap Panics
# Covers: unwrap(), expect(), unsafe blocks, transmute, raw pointers
# Rule IDs: null-pointer, expect-panic, rust-unsafe, rust-transmute, rust-raw-pointer

id: "RUST-MEMORY-SAFETY"
name: "Rust Memory Safety & Panic Risks"
language: "rust"
vulnerability_type: "memory_safety"
severity: "high"
cwe:
  - "CWE-476"
  - "CWE-787"
impact: "Panics in production or undefined behavior through unsafe operations"

test_cases:
  # TP: unwrap()
  - name: "unwrap on Option"
    vulnerable: true
    code: |
      fn get_value(map: &std::collections::HashMap<String, String>, key: &str) -> String {
          map.get(key).unwrap().clone()
      }
    expected_findings:
      - rule_id: "null-pointer"

  - name: "unwrap on Result"
    vulnerable: true
    code: |
      fn read_config() -> String {
          std::fs::read_to_string("config.toml").unwrap()
      }
    expected_findings:
      - rule_id: "null-pointer"

  - name: "chained unwrap"
    vulnerable: true
    code: |
      fn parse_port(s: &str) -> u16 {
          s.parse::<u16>().unwrap()
      }
    expected_findings:
      - rule_id: "null-pointer"

  # TP: expect()
  - name: "expect on Option"
    vulnerable: true
    code: |
      fn first_item(items: &[i32]) -> i32 {
          *items.first().expect("items should not be empty")
      }
    expected_findings:
      - rule_id: "expect-panic"

  - name: "expect on Result"
    vulnerable: true
    code: |
      fn connect() -> std::net::TcpStream {
          std::net::TcpStream::connect("127.0.0.1:8080").expect("failed to connect")
      }
    expected_findings:
      - rule_id: "expect-panic"

  # TP: unsafe block
  - name: "unsafe block with raw dereference"
    vulnerable: true
    code: |
      fn dangerous(ptr: *const i32) -> i32 {
          unsafe { *ptr }
      }
    expected_findings:
      - rule_id: "rust-unsafe"

  - name: "unsafe function"
    vulnerable: true
    code: |
      unsafe fn unchecked_access(data: &[u8], idx: usize) -> u8 {
          *data.get_unchecked(idx)
      }
    expected_findings:
      - rule_id: "rust-unsafe"

  # TP: transmute
  - name: "mem::transmute usage"
    vulnerable: true
    code: |
      fn cast_bytes(bytes: [u8; 4]) -> f32 {
          unsafe { std::mem::transmute(bytes) }
      }
    expected_findings:
      - rule_id: "rust-transmute"

  # FP: safe patterns
  - name: "unwrap_or with default (safe)"
    vulnerable: false
    code: |
      fn get_value(map: &std::collections::HashMap<String, String>, key: &str) -> String {
          map.get(key).cloned().unwrap_or_default()
      }

  - name: "match on Result (safe)"
    vulnerable: false
    code: |
      fn read_config() -> Result<String, std::io::Error> {
          match std::fs::read_to_string("config.toml") {
              Ok(content) => Ok(content),
              Err(e) => Err(e),
          }
      }

  - name: "question mark operator (safe)"
    vulnerable: false
    code: |
      fn parse_port(s: &str) -> Result<u16, std::num::ParseIntError> {
          let port = s.parse::<u16>()?;
          Ok(port)
      }

  - name: "if let pattern (safe)"
    vulnerable: false
    code: |
      fn first_or_zero(items: &[i32]) -> i32 {
          if let Some(first) = items.first() {
              *first
          } else {
              0
          }
      }

  - name: "safe type conversion (safe)"
    vulnerable: false
    code: |
      fn bytes_to_u32(bytes: &[u8]) -> Option<u32> {
          if bytes.len() < 4 {
              return None;
          }
          Some(u32::from_le_bytes([bytes[0], bytes[1], bytes[2], bytes[3]]))
      }
