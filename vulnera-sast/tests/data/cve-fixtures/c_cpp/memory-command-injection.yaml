# C/C++ Memory Management & Command Injection
# Covers: command injection, use-after-free, raw pointers, reinterpret_cast
# Rule IDs: c-command-injection, c-popen, c-use-after-free, cpp-raw-ptr, cpp-reinterpret-cast

id: "C-MEMORY-CMD"
name: "C/C++ Memory Management & Command Injection"
language: "c"
vulnerability_type: "memory_and_injection"
severity: "critical"
cwe:
  - "CWE-78"
  - "CWE-416"
  - "CWE-704"
impact: "Command injection, use-after-free, and unsafe type casting"

test_cases:
  # TP: command injection via system()
  - name: "system() call"
    vulnerable: true
    code: |
      #include <stdlib.h>
      void execute(const char *cmd) {
          system(cmd);
      }
    expected_findings:
      - rule_id: "c-command-injection"

  - name: "system() with string concatenation"
    vulnerable: true
    code: |
      #include <stdlib.h>
      #include <string.h>
      void run_tool(const char *filename) {
          char cmd[512];
          snprintf(cmd, sizeof(cmd), "process %s", filename);
          system(cmd);
      }
    expected_findings:
      - rule_id: "c-command-injection"

  # TP: popen
  - name: "popen for command execution"
    vulnerable: true
    code: |
      #include <stdio.h>
      FILE *run_command(const char *cmd) {
          return popen(cmd, "r");
      }
    expected_findings:
      - rule_id: "c-popen"

  - name: "popen with formatted command"
    vulnerable: true
    code: |
      #include <stdio.h>
      void read_output(const char *host) {
          char cmd[256];
          snprintf(cmd, sizeof(cmd), "ping -c 1 %s", host);
          FILE *fp = popen(cmd, "r");
          pclose(fp);
      }
    expected_findings:
      - rule_id: "c-popen"

  # TP: scanf
  - name: "scanf without width limit"
    vulnerable: true
    code: |
      #include <stdio.h>
      void read_name(void) {
          char name[32];
          scanf("%s", name);
      }
    expected_findings:
      - rule_id: "c-scanf"

  # TP: exec family
  - name: "execvp call"
    vulnerable: true
    code: |
      #include <unistd.h>
      void spawn(const char *prog, char *const argv[]) {
          execvp(prog, argv);
      }
    expected_findings:
      - rule_id: "c-exec"

  # FP: safe patterns
  - name: "static command with no user input (safe)"
    vulnerable: false
    code: |
      #include <stdlib.h>
      void cleanup(void) {
          remove("/tmp/lockfile");
      }

  - name: "fwrite for binary output (safe)"
    vulnerable: false
    code: |
      #include <stdio.h>
      void write_data(FILE *fp, const void *data, size_t len) {
          fwrite(data, 1, len, fp);
      }

  - name: "memset for initialization (safe)"
    vulnerable: false
    code: |
      #include <string.h>
      void init_buffer(char *buf, size_t len) {
          memset(buf, 0, len);
      }

  - name: "scanf with width specifier (safe)"
    vulnerable: false
    code: |
      #include <stdio.h>
      void read_name(void) {
          char name[32];
          scanf("%31s", name);
      }

  - name: "simple arithmetic (safe)"
    vulnerable: false
    code: |
      int add(int a, int b) {
          return a + b;
      }
