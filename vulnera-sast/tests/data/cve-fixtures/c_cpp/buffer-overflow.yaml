# C/C++ Buffer Overflow & Memory Safety
# Covers: strcpy, strcat, gets, sprintf, format string attacks
# Rule IDs: c-buffer-overflow, c-strcat, c-gets, c-sprintf, c-format-string

id: "C-BUFFER-OVERFLOW"
name: "C/C++ Buffer Overflow & Memory Safety"
language: "c"
vulnerability_type: "buffer_overflow"
severity: "critical"
cwe:
  - "CWE-120"
  - "CWE-121"
  - "CWE-134"
impact: "Stack/heap buffer overflow, arbitrary code execution, denial of service"

test_cases:
  # TP: strcpy
  - name: "strcpy without bounds checking"
    vulnerable: true
    code: |
      #include <string.h>
      void copy_input(char *dest, const char *src) {
          strcpy(dest, src);
      }
    expected_findings:
      - rule_id: "c-buffer-overflow"

  - name: "strcpy in struct initialization"
    vulnerable: true
    code: |
      #include <string.h>
      struct User {
          char name[64];
      };
      void init_user(struct User *u, const char *name) {
          strcpy(u->name, name);
      }
    expected_findings:
      - rule_id: "c-buffer-overflow"

  # TP: strcat
  - name: "strcat without size check"
    vulnerable: true
    code: |
      #include <string.h>
      void build_path(char *buf, const char *dir, const char *file) {
          strcat(buf, dir);
          strcat(buf, "/");
          strcat(buf, file);
      }
    expected_findings:
      - rule_id: "c-strcat"

  # TP: gets
  - name: "gets for user input"
    vulnerable: true
    code: |
      #include <stdio.h>
      void read_input(void) {
          char buffer[256];
          gets(buffer);
      }
    expected_findings:
      - rule_id: "c-gets"

  # TP: sprintf
  - name: "sprintf without bounds"
    vulnerable: true
    code: |
      #include <stdio.h>
      void format_greeting(char *buf, const char *name) {
          sprintf(buf, "Hello, %s!", name);
      }
    expected_findings:
      - rule_id: "c-sprintf"

  - name: "sprintf with user input"
    vulnerable: true
    code: |
      #include <stdio.h>
      void log_message(char *buf, const char *user, const char *action) {
          sprintf(buf, "[%s] %s", user, action);
      }
    expected_findings:
      - rule_id: "c-sprintf"

  # TP: format string
  - name: "printf with user-controlled format"
    vulnerable: true
    code: |
      #include <stdio.h>
      void log_input(const char *user_message) {
          printf(user_message);
      }
    expected_findings:
      - rule_id: "c-format-string"

  # FP: safe alternatives
  - name: "strncpy with bounds (safe)"
    vulnerable: false
    code: |
      #include <string.h>
      void copy_safe(char *dest, const char *src, size_t dest_size) {
          strncpy(dest, src, dest_size - 1);
          dest[dest_size - 1] = '\0';
      }

  - name: "snprintf instead of sprintf (safe)"
    vulnerable: false
    code: |
      #include <stdio.h>
      void format_greeting(char *buf, size_t bufsize, const char *name) {
          snprintf(buf, bufsize, "Hello, %s!", name);
      }

  - name: "fgets instead of gets (safe)"
    vulnerable: false
    code: |
      #include <stdio.h>
      void read_input(void) {
          char buffer[256];
          fgets(buffer, sizeof(buffer), stdin);
      }

  - name: "printf with format literal (safe)"
    vulnerable: false
    code: |
      #include <stdio.h>
      void log_input(const char *message) {
          printf("%s\n", message);
      }

  - name: "strncat with length (safe)"
    vulnerable: false
    code: |
      #include <string.h>
      void safe_concat(char *buf, size_t bufsize, const char *suffix) {
          size_t current = strlen(buf);
          size_t remaining = bufsize - current - 1;
          strncat(buf, suffix, remaining);
      }
