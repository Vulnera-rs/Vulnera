# Zip Slip Path Traversal Vulnerability
# Originally disclosed by Snyk in 2018, affected thousands of projects
# CVEs include: CVE-2018-1000001, CVE-2018-1000544, CVE-2018-16385, many more
# Impact: Arbitrary file write leading to RCE

id: "ZIP-SLIP"
name: "Zip Slip Path Traversal"
language: "javascript"
vulnerability_type: "path_traversal"
severity: "critical"
cwe:
  - "CWE-22"
  - "CWE-73"
impact: "Arbitrary file write/overwrite; attackers can overwrite configuration files, executables, or startup scripts leading to Remote Code Execution"
description: |
  Zip Slip is a critical vulnerability that occurs when extracting archives without
  validating file paths. Archives can contain entries with "../" sequences that,
  when extracted, write files outside the intended directory.
  
  Discovered by Snyk in 2018, this vulnerability affected major projects including
  npm packages, Java libraries, .NET tools, and Go utilities. The attack can lead
  to arbitrary file overwrite, which typically results in RCE by overwriting
  executables or configuration files.
  
  Real-world impact: Over 4,500 projects were found vulnerable at disclosure.

test_cases:
  # Vulnerable patterns
  - name: "unzip without path validation"
    vulnerable: true
    code: |
      const unzip = require('unzip');
      const fs = require('fs');
      const path = require('path');
      const express = require('express');
      const app = express();

      app.post('/upload', (req, res) => {
          req.pipe(unzip.Extract({ path: '/uploads' }))
              .on('entry', (entry) => {
                  const filepath = path.join('/uploads', entry.path);
                  // VULNERABLE: entry.path could be ../../../etc/passwd
                  fs.createWriteStream(filepath);
              });
      });
    expected_findings:
      - rule_id: "path_traversal"
        line: 11
        severity: "high"
        message_contains: "path"
    taint_path: "entry.path (from archive) → path.join() → fs.createWriteStream()"

  - name: "adm-zip without path validation"
    vulnerable: true
    code: |
      const AdmZip = require('adm-zip');
      const fs = require('fs');
      const path = require('path');

      function extractArchive(req, res) {
          const zip = new AdmZip(req.file.buffer);
          const entries = zip.getEntries();
          
          entries.forEach((entry) => {
              const targetPath = path.join('./extracted', entry.entryName);
              // VULNERABLE: entryName can contain ../
              fs.writeFileSync(targetPath, entry.getData());
          });
      }
    expected_findings:
      - rule_id: "path_traversal"
        line: 11
        severity: "high"
    taint_path: "entry.entryName (from archive) → path.join() → fs.writeFileSync()"

  - name: "tar extraction without validation"
    vulnerable: true
    code: |
      const tar = require('tar');
      const fs = require('fs');
      const express = require('express');

      app.post('/extract-tar', async (req, res) => {
          const stream = req;
          await tar.extract({
              cwd: '/data/uploads',
              // VULNERABLE: No filter to prevent path traversal
          }).end(req.file.buffer);
          res.send('Extracted');
      });
    expected_findings:
      - rule_id: "path_traversal"
        line: 7
        severity: "high"
    taint_path: "req (stream) → tar.extract() without filter"

  - name: "yauzl zip extraction without validation"
    vulnerable: true
    code: |
      const yauzl = require('yauzl');
      const fs = require('fs');
      const path = require('path');

      function extractZip(zipBuffer, targetDir, callback) {
          yauzl.fromBuffer(zipBuffer, (err, zipfile) => {
              zipfile.on('entry', (entry) => {
                  const destPath = path.join(targetDir, entry.fileName);
                  // VULNERABLE: fileName could escape targetDir
                  const writeStream = fs.createWriteStream(destPath);
                  zipfile.openReadStream(entry, (err, readStream) => {
                      readStream.pipe(writeStream);
                  });
              });
          });
      }
    expected_findings:
      - rule_id: "path_traversal"
        line: 9
        severity: "high"
    taint_path: "entry.fileName → path.join() → fs.createWriteStream()"

  - name: "decompress library without filter"
    vulnerable: true
    code: |
      const decompress = require('decompress');

      async function handleUpload(req, res) {
          const buffer = req.file.buffer;
          // VULNERABLE: decompress without strip option or filter
          await decompress(buffer, 'output');
          res.send('Done');
      }
    expected_findings:
      - rule_id: "path_traversal"
        line: 6
        severity: "high"
    taint_path: "req.file.buffer → decompress() without validation"

  # Safe patterns
  - name: "path validation before extraction"
    vulnerable: false
    code: |
      const AdmZip = require('adm-zip');
      const fs = require('fs');
      const path = require('path');

      function extractArchiveSafe(req, res) {
          const zip = new AdmZip(req.file.buffer);
          const entries = zip.getEntries();
          const targetDir = path.resolve('./extracted');
          
          entries.forEach((entry) => {
              const targetPath = path.resolve(targetDir, entry.entryName);
              
              // SAFE: Validate that resolved path is within target directory
              if (!targetPath.startsWith(targetDir + path.sep)) {
                  throw new Error('Path traversal detected');
              }
              
              fs.writeFileSync(targetPath, entry.getData());
          });
      }
    expected_findings: []

  - name: "using path.basename to strip directory"
    vulnerable: false
    code: |
      const yauzl = require('yauzl');
      const fs = require('fs');
      const path = require('path');

      function extractZipSafe(zipBuffer, targetDir) {
          yauzl.fromBuffer(zipBuffer, (err, zipfile) => {
              zipfile.on('entry', (entry) => {
                  // SAFE: Use basename to get only the filename, stripping ../
                  const safeName = path.basename(entry.fileName);
                  const destPath = path.join(targetDir, safeName);
                  const writeStream = fs.createWriteStream(destPath);
                  zipfile.openReadStream(entry, (err, readStream) => {
                      readStream.pipe(writeStream);
                  });
              });
          });
      }
    expected_findings: []

  - name: "tar with filter function"
    vulnerable: false
    code: |
      const tar = require('tar');

      async function extractTarSafe(buffer, targetDir) {
          await tar.extract({
              cwd: targetDir,
              // SAFE: Filter out entries with suspicious paths
              filter: (path, entry) => {
                  if (path.includes('..')) {
                      return false;
                  }
                  return true;
              }
          }).end(buffer);
      }
    expected_findings: []

  - name: "decompress with strip option"
    vulnerable: false
    code: |
      const decompress = require('decompress');

      async function handleUploadSafe(req, res) {
          const buffer = req.file.buffer;
          // SAFE: strip removes leading directory components, preventing traversal
          await decompress(buffer, 'output', { strip: 1 });
          res.send('Done');
      }
    expected_findings: []
