# Go Command Injection & SQL Injection
# Covers: exec.Command, sql string formatting, unsafe pointer
# Rule IDs: go-command-injection, go-sql-injection, go-unsafe, go-ssrf

id: "GO-CMD-SQL-INJECTION"
name: "Go Command & SQL Injection"
language: "go"
vulnerability_type: "injection"
severity: "high"
cwe:
  - "CWE-78"
  - "CWE-89"
impact: "Command injection and SQL injection in Go applications"

test_cases:
  # TP: command injection
  - name: "exec.Command with variable"
    vulnerable: true
    code: |
      package main
      import "os/exec"
      func runCommand(cmd string) error {
          return exec.Command(cmd).Run()
      }
    expected_findings:
      - rule_id: "go-command-injection"

  - name: "exec.Command with arguments"
    vulnerable: true
    code: |
      package main
      import "os/exec"
      func execute(program string, args ...string) ([]byte, error) {
          cmd := exec.Command(program, args...)
          return cmd.Output()
      }
    expected_findings:
      - rule_id: "go-command-injection"

  # TP: SQL injection
  - name: "fmt.Sprintf SQL query"
    vulnerable: true
    code: |
      package main
      import (
          "database/sql"
          "fmt"
      )
      func findUser(db *sql.DB, id string) (*sql.Row) {
          query := fmt.Sprintf("SELECT * FROM users WHERE id = '%s'", id)
          return db.QueryRow(query)
      }
    expected_findings:
      - rule_id: "go-sql-injection"

  - name: "string concatenation SQL"
    vulnerable: true
    code: |
      package main
      import "database/sql"
      func search(db *sql.DB, name string) (*sql.Rows, error) {
          query := "SELECT * FROM users WHERE name = '" + name + "'"
          return db.Query(query)
      }
    expected_findings:
      - rule_id: "go-sql-injection"

  # TP: unsafe pointer
  - name: "unsafe.Pointer usage"
    vulnerable: true
    code: |
      package main
      import "unsafe"
      func castPointer(p *int) *float64 {
          return (*float64)(unsafe.Pointer(p))
      }
    expected_findings:
      - rule_id: "go-unsafe"

  - name: "uintptr arithmetic"
    vulnerable: true
    code: |
      package main
      import "unsafe"
      func offsetAccess(data []byte, offset uintptr) byte {
          ptr := unsafe.Pointer(&data[0])
          return *(*byte)(unsafe.Add(ptr, offset))
      }
    expected_findings:
      - rule_id: "go-unsafe"

  # TP: SSRF
  - name: "http.Get with user URL"
    vulnerable: true
    code: |
      package main
      import "net/http"
      func fetch(url string) (*http.Response, error) {
          return http.Get(url)
      }
    expected_findings:
      - rule_id: "go-ssrf"

  # FP: safe patterns
  - name: "exec.Command with hardcoded command (safe)"
    vulnerable: false
    code: |
      package main
      import "os/exec"
      func listDir() ([]byte, error) {
          return exec.Command("ls", "-la").Output()
      }

  - name: "parameterized SQL query (safe)"
    vulnerable: false
    code: |
      package main
      import "database/sql"
      func findUser(db *sql.DB, id int64) *sql.Row {
          return db.QueryRow("SELECT * FROM users WHERE id = $1", id)
      }

  - name: "safe type conversion (safe)"
    vulnerable: false
    code: |
      package main
      import "strconv"
      func parseAge(s string) (int, error) {
          return strconv.Atoi(s)
      }

  - name: "http.Get with hardcoded URL (safe)"
    vulnerable: false
    code: |
      package main
      import "net/http"
      func healthCheck() (*http.Response, error) {
          return http.Get("https://api.example.com/health")
      }

  - name: "pure computation (safe)"
    vulnerable: false
    code: |
      package main
      func sum(nums []int) int {
          total := 0
          for _, n := range nums {
              total += n
          }
          return total
      }
