# Go SSRF (Server-Side Request Forgery) Vulnerabilities
# Including CVE-2021-33197 (net/http header splitting) and general SSRF patterns
# Impact: Internal network access, cloud metadata exfiltration, port scanning

id: "GO-SSRF"
name: "Go Server-Side Request Forgery (SSRF)"
language: "go"
vulnerability_type: "ssrf"
severity: "high"
cwe:
  - "CWE-918"
  - "CWE-441"
impact: "Access to internal network resources; exfiltration of cloud metadata (AWS/GCP credentials); internal service enumeration; potential for further exploitation"
description: |
  Server-Side Request Forgery (SSRF) occurs when an attacker can make the server
  perform HTTP requests to arbitrary URLs. In Go, this commonly happens when
  user input is directly used in http.Get(), http.Post(), or http.NewRequest()
  without proper validation.
  
  Critical targets include:
  - Cloud metadata endpoints (169.254.169.254)
  - Internal services (localhost, 10.x.x.x, 192.168.x.x)
  - Other backends (Redis, databases, admin panels)
  
  CVE-2021-33197 specifically affected Go's net/http with header injection,
  but SSRF is a broader class affecting many Go applications.

test_cases:
  # Vulnerable patterns
  - name: "http.Get with user-controlled URL"
    vulnerable: true
    code: |
      package main

      import (
          "io"
          "net/http"
      )

      func proxyHandler(w http.ResponseWriter, r *http.Request) {
          targetURL := r.URL.Query().Get("url")
          // VULNERABLE: User controls the entire URL
          resp, err := http.Get(targetURL)
          if err != nil {
              http.Error(w, err.Error(), http.StatusBadGateway)
              return
          }
          defer resp.Body.Close()
          io.Copy(w, resp.Body)
      }
    expected_findings:
      - rule_id: "ssrf"
        line: 11
        severity: "high"
        message_contains: "SSRF"
    taint_path: "r.URL.Query().Get() → http.Get()"

  - name: "http.Post with user URL"
    vulnerable: true
    code: |
      package main

      import (
          "net/http"
          "strings"
      )

      func webhookHandler(w http.ResponseWriter, r *http.Request) {
          webhookURL := r.FormValue("webhook_url")
          payload := r.FormValue("payload")
          // VULNERABLE: User controls webhook destination
          resp, _ := http.Post(webhookURL, "application/json", strings.NewReader(payload))
          w.WriteHeader(resp.StatusCode)
      }
    expected_findings:
      - rule_id: "ssrf"
        line: 12
        severity: "high"
    taint_path: "r.FormValue('webhook_url') → http.Post()"

  - name: "http.NewRequest with user URL"
    vulnerable: true
    code: |
      package main

      import (
          "net/http"
      )

      func fetchResource(w http.ResponseWriter, r *http.Request) {
          resourceURL := r.URL.Query().Get("resource")
          // VULNERABLE: User controls URL in request
          req, _ := http.NewRequest("GET", resourceURL, nil)
          client := &http.Client{}
          resp, _ := client.Do(req)
          defer resp.Body.Close()
      }
    expected_findings:
      - rule_id: "ssrf"
        line: 10
        severity: "high"
    taint_path: "r.URL.Query().Get() → http.NewRequest()"

  - name: "URL concatenation SSRF"
    vulnerable: true
    code: |
      package main

      import (
          "fmt"
          "net/http"
      )

      func imageProxy(w http.ResponseWriter, r *http.Request) {
          imageID := r.URL.Query().Get("id")
          // VULNERABLE: Even with base URL, attacker can use @ or # to redirect
          // Example: id=@evil.com/malicious or id=../../../internal
          url := fmt.Sprintf("https://images.example.com/%s", imageID)
          resp, _ := http.Get(url)
          defer resp.Body.Close()
      }
    expected_findings:
      - rule_id: "ssrf"
        line: 13
        severity: "high"
    taint_path: "r.URL.Query().Get() → fmt.Sprintf() → http.Get()"

  - name: "http redirect following (open redirect to SSRF)"
    vulnerable: true
    code: |
      package main

      import (
          "net/http"
      )

      func redirectHandler(w http.ResponseWriter, r *http.Request) {
          target := r.URL.Query().Get("url")
          // VULNERABLE: Go's http.Client follows redirects by default
          // Attacker can use http://external.com which 302s to http://169.254.169.254
          client := &http.Client{}
          resp, _ := client.Get(target)
          defer resp.Body.Close()
      }
    expected_findings:
      - rule_id: "ssrf"
        line: 12
        severity: "high"
    taint_path: "r.URL.Query().Get() → client.Get() (follows redirects)"

  # Safe patterns
  - name: "URL validation with allowlist"
    vulnerable: false
    code: |
      package main

      import (
          "net/http"
          "net/url"
          "strings"
      )

      var allowedHosts = map[string]bool{
          "api.example.com":    true,
          "images.example.com": true,
      }

      func safeProxy(w http.ResponseWriter, r *http.Request) {
          targetURL := r.URL.Query().Get("url")
          
          // SAFE: Parse and validate URL
          u, err := url.Parse(targetURL)
          if err != nil {
              http.Error(w, "Invalid URL", http.StatusBadRequest)
              return
          }
          
          // SAFE: Check against allowlist
          if !allowedHosts[u.Host] {
              http.Error(w, "Host not allowed", http.StatusForbidden)
              return
          }
          
          // SAFE: Only allow HTTPS
          if u.Scheme != "https" {
              http.Error(w, "Only HTTPS allowed", http.StatusBadRequest)
              return
          }
          
          resp, _ := http.Get(u.String())
          defer resp.Body.Close()
      }
    expected_findings: []

  - name: "blocking internal IP ranges"
    vulnerable: false
    code: |
      package main

      import (
          "net"
          "net/http"
          "net/url"
      )

      func isInternalIP(ip net.IP) bool {
          privateRanges := []string{
              "10.0.0.0/8",
              "172.16.0.0/12",
              "192.168.0.0/16",
              "127.0.0.0/8",
              "169.254.0.0/16",
          }
          for _, cidr := range privateRanges {
              _, network, _ := net.ParseCIDR(cidr)
              if network.Contains(ip) {
                  return true
              }
          }
          return false
      }

      func safeRequest(w http.ResponseWriter, r *http.Request) {
          targetURL := r.URL.Query().Get("url")
          u, _ := url.Parse(targetURL)
          
          // SAFE: Resolve hostname and check if it's internal
          ips, _ := net.LookupIP(u.Hostname())
          for _, ip := range ips {
              if isInternalIP(ip) {
                  http.Error(w, "Internal IPs not allowed", http.StatusForbidden)
                  return
              }
          }
          
          resp, _ := http.Get(targetURL)
          defer resp.Body.Close()
      }
    expected_findings: []

  - name: "using predefined base URL only"
    vulnerable: false
    code: |
      package main

      import (
          "net/http"
          "path"
      )

      const baseURL = "https://api.internal.example.com"

      func fetchData(w http.ResponseWriter, r *http.Request) {
          resourceID := r.URL.Query().Get("id")
          
          // SAFE: User only controls path segment, validated against path traversal
          cleanID := path.Clean(resourceID)
          if cleanID != resourceID || strings.Contains(cleanID, "..") {
              http.Error(w, "Invalid ID", http.StatusBadRequest)
              return
          }
          
          // SAFE: Base URL is hardcoded, only clean ID is appended
          fullURL := baseURL + "/resources/" + cleanID
          resp, _ := http.Get(fullURL)
          defer resp.Body.Close()
      }
    expected_findings: []

  - name: "disable redirect following"
    vulnerable: false
    code: |
      package main

      import (
          "errors"
          "net/http"
      )

      func noRedirectProxy(w http.ResponseWriter, r *http.Request) {
          targetURL := r.URL.Query().Get("url")
          
          // SAFE: Client configured to not follow redirects
          client := &http.Client{
              CheckRedirect: func(req *http.Request, via []*http.Request) error {
                  return errors.New("redirects not allowed")
              },
          }
          
          // Still need URL validation in practice, but redirect blocking helps
          resp, _ := client.Get(targetURL)
          if resp != nil {
              defer resp.Body.Close()
          }
      }
    expected_findings: []
