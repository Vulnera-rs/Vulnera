//! Vulnerability advisor integration module
//!
//! This module provides an adapter that wraps the `vulnera-advisor` crate to implement
//! our domain's `IVulnerabilityRepository` trait. The adapter handles:
//!
//! - Converting between `vulnera-advisor` types and our domain entities
//! - Managing the vulnerability manager lifecycle
//! - Providing transparent access to multiple vulnerability sources (OSV, NVD, GHSA, KEV, EPSS)
//!
//! # Architecture
//!
//! ```text
//!                      +----------------------+
//!                      | IVulnerabilityRepo   |
//!                      +----------+-----------+
//!                                 |
//!                      +----------v-----------+
//!                      | VulneraAdvisorRepo   |  (This adapter)
//!                      +----------+-----------+
//!                                 |
//!                      +----------v-----------+
//!                      | VulnerabilityManager |  (vulnera-advisor crate)
//!                      +----------+-----------+
//!               +-------------+---+---+-------------+
//!               |             |       |             |
//!           +---v---+     +---v---+ +-v--+     +----v---+
//!           |  OSV  |     |  NVD  | |GHSA|     |OSS Idx |
//!           +-------+     +-------+ +----+     +--------+
//! ```

use std::sync::Arc;

use async_trait::async_trait;
use chrono::Utc;
use tracing::{debug, info, warn};
use vulnera_advisor::{
    MatchOptions, VulnerabilityManager, VulnerabilityManagerBuilder,
    models::{Advisory, Severity as AdvisorSeverity},
};

use crate::application::errors::VulnerabilityError;
use crate::config::Config;
use crate::domain::vulnerability::entities::{AffectedPackage, Package, Vulnerability};
use crate::domain::vulnerability::repositories::IVulnerabilityRepository;
use crate::domain::vulnerability::value_objects::{
    Ecosystem, Severity, Version, VersionRange, VulnerabilityId, VulnerabilitySource,
};

/// Configuration for the vulnerability advisor repository
#[derive(Debug, Clone)]
pub struct VulneraAdvisorConfig {
    /// Redis/Dragonfly URL for the advisory store
    pub redis_url: String,
    /// GitHub token for GHSA access
    pub ghsa_token: Option<String>,
    /// NVD API key for enhanced rate limits
    pub nvd_api_key: Option<String>,
    /// Whether to include enrichment data (EPSS, KEV)
    pub include_enrichment: bool,
    /// OSS Index username (optional)
    pub ossindex_username: Option<String>,
    /// OSS Index token (optional)
    pub ossindex_token: Option<String>,
}

impl VulneraAdvisorConfig {
    /// Create configuration from the main application config
    pub fn from_config(config: &Config) -> Self {
        Self {
            redis_url: config.cache.dragonfly_url.clone(),
            ghsa_token: config.apis.ghsa.token.clone(),
            nvd_api_key: config.apis.nvd.api_key.clone(),
            include_enrichment: true,
            ossindex_username: None,
            ossindex_token: None,
        }
    }
}

/// Repository implementation that wraps vulnera-advisor's VulnerabilityManager
///
pub struct VulneraAdvisorRepository {
    manager: Arc<VulnerabilityManager>,
    include_enrichment: bool,
}

impl VulneraAdvisorRepository {
    /// Create a new repository with the given configuration
    pub async fn new(config: VulneraAdvisorConfig) -> Result<Self, VulnerabilityError> {
        let mut builder = VulnerabilityManagerBuilder::new()
            .redis_url(&config.redis_url)
            .with_osv_defaults();

        // Add NVD source
        builder = builder.with_nvd(config.nvd_api_key);

        // Add GHSA source if token is provided
        if let Some(token) = config.ghsa_token {
            if !token.trim().is_empty() {
                builder = builder.with_ghsa(token);
            }
        }

        // Add OSS Index if configured
        if config.ossindex_username.is_some() || config.ossindex_token.is_some() {
            builder = builder.with_ossindex(None);
        }

        let manager = builder
            .build()
            .map_err(|e| VulnerabilityError::Repository {
                message: format!("Failed to build vulnerability manager: {}", e),
            })?;

        info!("Initialized VulneraAdvisorRepository with vulnera-advisor");

        Ok(Self {
            manager: Arc::new(manager),
            include_enrichment: config.include_enrichment,
        })
    }

    /// Create a repository from the main application config
    pub async fn from_config(config: &Config) -> Result<Self, VulnerabilityError> {
        Self::new(VulneraAdvisorConfig::from_config(config)).await
    }

    /// Get a reference to the underlying manager for advanced operations
    pub fn manager(&self) -> &VulnerabilityManager {
        &self.manager
    }

    /// Sync all vulnerability sources (call periodically or on startup)
    pub async fn sync_all(&self) -> Result<(), VulnerabilityError> {
        self.manager
            .sync_all()
            .await
            .map_err(|e| VulnerabilityError::Repository {
                message: format!("Failed to sync vulnerability sources: {}", e),
            })
    }

    /// Sync enrichment data (KEV, EPSS)
    pub async fn sync_enrichment(&self) -> Result<(), VulnerabilityError> {
        self.manager
            .sync_enrichment()
            .await
            .map_err(|e| VulnerabilityError::Repository {
                message: format!("Failed to sync enrichment data: {}", e),
            })
    }

    /// Convert ecosystem enum to string for vulnera-advisor
    fn ecosystem_to_string(ecosystem: &Ecosystem) -> &'static str {
        match ecosystem {
            Ecosystem::Npm => "npm",
            Ecosystem::PyPI => "PyPI",
            Ecosystem::Maven => "Maven",
            Ecosystem::Cargo => "crates.io",
            Ecosystem::Go => "Go",
            Ecosystem::Packagist => "Packagist",
            Ecosystem::RubyGems => "RubyGems",
            Ecosystem::NuGet => "NuGet",
        }
    }

    /// Convert string ecosystem to domain enum
    fn string_to_ecosystem(ecosystem: &str) -> Option<Ecosystem> {
        match ecosystem.to_lowercase().as_str() {
            "npm" => Some(Ecosystem::Npm),
            "pypi" => Some(Ecosystem::PyPI),
            "maven" => Some(Ecosystem::Maven),
            "crates.io" | "cargo" => Some(Ecosystem::Cargo),
            "go" => Some(Ecosystem::Go),
            "packagist" => Some(Ecosystem::Packagist),
            "rubygems" => Some(Ecosystem::RubyGems),
            "nuget" => Some(Ecosystem::NuGet),
            _ => None,
        }
    }

    /// Convert advisor severity to domain severity
    fn convert_severity(severity: Option<&AdvisorSeverity>) -> Severity {
        match severity {
            Some(AdvisorSeverity::Critical) => Severity::Critical,
            Some(AdvisorSeverity::High) => Severity::High,
            Some(AdvisorSeverity::Medium) => Severity::Medium,
            Some(AdvisorSeverity::Low) => Severity::Low,
            Some(AdvisorSeverity::None) | None => Severity::Medium, // Default to medium if unknown
        }
    }

    /// Determine the source from advisory ID
    fn determine_source(advisory: &Advisory) -> Vec<VulnerabilitySource> {
        let mut sources = Vec::new();

        if advisory.id.starts_with("GHSA-") {
            sources.push(VulnerabilitySource::GHSA);
        } else if advisory.id.starts_with("CVE-") {
            sources.push(VulnerabilitySource::NVD);
        }

        // Check aliases for additional sources
        if let Some(aliases) = &advisory.aliases {
            for alias in aliases {
                if alias.starts_with("GHSA-") && !sources.contains(&VulnerabilitySource::GHSA) {
                    sources.push(VulnerabilitySource::GHSA);
                } else if alias.starts_with("CVE-") && !sources.contains(&VulnerabilitySource::NVD)
                {
                    sources.push(VulnerabilitySource::NVD);
                }
            }
        }

        // If no specific source detected, assume OSV
        if sources.is_empty() {
            sources.push(VulnerabilitySource::OSV);
        }

        sources
    }

    /// Convert an advisory to our domain Vulnerability entity
    fn convert_advisory(
        &self,
        advisory: Advisory,
        queried_package: &Package,
    ) -> Result<Vulnerability, String> {
        let vuln_id =
            VulnerabilityId::new(advisory.id.clone()).map_err(|e| format!("Invalid ID: {}", e))?;

        // Get severity from enrichment data or default to Medium
        let severity = advisory
            .enrichment
            .as_ref()
            .and_then(|e| e.cvss_v3_severity.as_ref())
            .map(|s| Self::convert_severity(Some(s)))
            .unwrap_or(Severity::Medium);

        let sources = Self::determine_source(&advisory);

        // Build affected packages from advisory data
        let mut affected_packages = Vec::new();

        for affected in &advisory.affected {
            let ecosystem = match Self::string_to_ecosystem(&affected.package.ecosystem) {
                Some(e) => e,
                None => {
                    debug!(
                        "Unknown ecosystem '{}' in advisory {}, skipping",
                        affected.package.ecosystem, advisory.id
                    );
                    continue;
                }
            };

            // Parse version ranges from the affected data
            let mut version_ranges = Vec::new();
            let mut fixed_versions = Vec::new();

            for range in &affected.ranges {
                let mut introduced_version = None;
                let mut fixed_version = None;
                let mut last_affected_version = None;

                for event in &range.events {
                    match event {
                        vulnera_advisor::models::Event::Introduced(v) => {
                            if v != "0" {
                                introduced_version = Version::parse(v).ok();
                            }
                        }
                        vulnera_advisor::models::Event::Fixed(v) => {
                            if let Ok(ver) = Version::parse(v) {
                                fixed_version = Some(ver.clone());
                                fixed_versions.push(ver);
                            }
                        }
                        vulnera_advisor::models::Event::LastAffected(v) => {
                            last_affected_version = Version::parse(v).ok();
                        }
                        vulnera_advisor::models::Event::Limit(_) => {}
                    }
                }

                // Build version range based on events
                if let (Some(intro), Some(fixed)) = (&introduced_version, &fixed_version) {
                    version_ranges.push(VersionRange::new(
                        Some(intro.clone()),
                        Some(fixed.clone()),
                        true,
                        false,
                    ));
                } else if introduced_version.is_none() && fixed_version.is_some() {
                    if let Some(fixed) = &fixed_version {
                        version_ranges.push(VersionRange::less_than(fixed.clone()));
                    }
                } else if introduced_version.is_some()
                    && last_affected_version.is_some()
                    && fixed_version.is_none()
                {
                    if let (Some(intro), Some(last)) = (&introduced_version, &last_affected_version)
                    {
                        version_ranges.push(VersionRange::new(
                            Some(intro.clone()),
                            Some(last.clone()),
                            true,
                            true,
                        ));
                    }
                } else if let Some(intro) = &introduced_version {
                    version_ranges.push(VersionRange::at_least(intro.clone()));
                }
            }

            // Also check explicit versions list
            for version_str in &affected.versions {
                if let Ok(version) = Version::parse(version_str) {
                    version_ranges.push(VersionRange::exact(version));
                }
            }

            if !version_ranges.is_empty() {
                // Use the first fixed version or a default
                let default_version = fixed_versions
                    .first()
                    .cloned()
                    .unwrap_or_else(|| Version::parse("1.0.0").unwrap());

                if let Ok(package) =
                    Package::new(affected.package.name.clone(), default_version, ecosystem)
                {
                    let affected_pkg =
                        AffectedPackage::new(package, version_ranges, fixed_versions.clone());
                    affected_packages.push(affected_pkg);
                }
            }
        }

        // Filter to only packages matching the queried one and version
        affected_packages.retain(|ap| {
            ap.package.matches(queried_package) && ap.is_vulnerable(&queried_package.version)
        });

        if affected_packages.is_empty() {
            return Err("No affected packages match the queried package/version".to_string());
        }

        // Build references list
        let references: Vec<String> = advisory.references.iter().map(|r| r.url.clone()).collect();

        // Use summary or first part of details
        let summary = advisory
            .summary
            .clone()
            .or_else(|| {
                advisory
                    .details
                    .as_ref()
                    .map(|d| d.split('.').next().unwrap_or(d).chars().take(200).collect())
            })
            .unwrap_or_else(|| format!("Vulnerability {}", advisory.id));

        let description = advisory.details.clone().unwrap_or_else(|| summary.clone());

        let published_at = advisory.published.unwrap_or_else(Utc::now);

        Vulnerability::new(
            vuln_id,
            summary,
            description,
            severity,
            affected_packages,
            references,
            published_at,
            sources,
        )
    }
}

#[async_trait]
impl IVulnerabilityRepository for VulneraAdvisorRepository {
    #[tracing::instrument(skip(self))]
    async fn find_vulnerabilities(
        &self,
        package: &Package,
    ) -> Result<Vec<Vulnerability>, VulnerabilityError> {
        let ecosystem_str = Self::ecosystem_to_string(&package.ecosystem);
        let version_str = package.version.to_string();

        debug!(
            "Querying vulnerabilities for {}:{} @ {}",
            ecosystem_str, package.name, version_str
        );

        let options = if self.include_enrichment {
            MatchOptions::with_enrichment()
        } else {
            MatchOptions::default()
        };

        let advisories = self
            .manager
            .matches_with_options(ecosystem_str, &package.name, &version_str, &options)
            .await
            .map_err(|e| VulnerabilityError::Repository {
                message: format!("Failed to query vulnerabilities: {}", e),
            })?;

        info!(
            "Found {} advisories for {} @ {}",
            advisories.len(),
            package.identifier(),
            version_str
        );

        // Convert advisories to domain vulnerabilities
        let mut vulnerabilities = Vec::with_capacity(advisories.len());
        for advisory in advisories {
            match self.convert_advisory(advisory, package) {
                Ok(vuln) => vulnerabilities.push(vuln),
                Err(e) => {
                    warn!(
                        "Failed to convert advisory for {}: {}",
                        package.identifier(),
                        e
                    );
                }
            }
        }

        Ok(vulnerabilities)
    }

    #[tracing::instrument(skip(self))]
    async fn get_vulnerability_by_id(
        &self,
        id: &VulnerabilityId,
    ) -> Result<Option<Vulnerability>, VulnerabilityError> {
        // vulnera-advisor doesn't have a direct get-by-id method,
        // so we need to search through the store or return None for now
        // This is a limitation - in practice, most queries go through find_vulnerabilities
        debug!(
            "get_vulnerability_by_id called for {} - limited support",
            id.as_str()
        );

        // Try to get from store directly if it's a known ID format
        // For now, return None as this is rarely used in practice
        warn!(
            "get_vulnerability_by_id not fully supported by vulnera-advisor adapter: {}",
            id.as_str()
        );
        Ok(None)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ecosystem_conversion() {
        assert_eq!(
            VulneraAdvisorRepository::ecosystem_to_string(&Ecosystem::Npm),
            "npm"
        );
        assert_eq!(
            VulneraAdvisorRepository::ecosystem_to_string(&Ecosystem::PyPI),
            "PyPI"
        );
        assert_eq!(
            VulneraAdvisorRepository::ecosystem_to_string(&Ecosystem::Cargo),
            "crates.io"
        );

        assert_eq!(
            VulneraAdvisorRepository::string_to_ecosystem("npm"),
            Some(Ecosystem::Npm)
        );
        assert_eq!(
            VulneraAdvisorRepository::string_to_ecosystem("PyPI"),
            Some(Ecosystem::PyPI)
        );
        assert_eq!(
            VulneraAdvisorRepository::string_to_ecosystem("crates.io"),
            Some(Ecosystem::Cargo)
        );
        assert_eq!(
            VulneraAdvisorRepository::string_to_ecosystem("unknown"),
            None
        );
    }

    #[test]
    fn test_severity_conversion() {
        assert_eq!(
            VulneraAdvisorRepository::convert_severity(Some(&AdvisorSeverity::Critical)),
            Severity::Critical
        );
        assert_eq!(
            VulneraAdvisorRepository::convert_severity(Some(&AdvisorSeverity::High)),
            Severity::High
        );
        assert_eq!(
            VulneraAdvisorRepository::convert_severity(Some(&AdvisorSeverity::Medium)),
            Severity::Medium
        );
        assert_eq!(
            VulneraAdvisorRepository::convert_severity(Some(&AdvisorSeverity::Low)),
            Severity::Low
        );
        assert_eq!(
            VulneraAdvisorRepository::convert_severity(None),
            Severity::Medium
        );
    }
}
