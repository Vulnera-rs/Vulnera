//! Unit tests for ExplainVulnerabilityUseCase

use std::sync::Arc;
use vulnera_llm::application::use_cases::ExplainVulnerabilityUseCase;

mod common {
    include!("../common/mod.rs");
}

use common::{create_streaming_response, create_test_config, MockLlmProvider};

/// Test successful vulnerability explanation streaming
#[tokio::test]
async fn test_explain_vulnerability_stream_success() {
    let response = create_streaming_response(
        "This vulnerability allows attackers to execute arbitrary code...",
    );
    let provider = Arc::new(MockLlmProvider::new().with_response(response));
    let config = create_test_config();
    let use_case = ExplainVulnerabilityUseCase::new(provider, config);

    let result = use_case
        .execute_stream(
            "CVE-2021-44228",
            "Critical",
            "Log4j JNDI injection vulnerability",
        )
        .await;

    assert!(result.is_ok());

    let mut rx = result.unwrap();
    let chunk = rx.recv().await;
    assert!(chunk.is_some());
    assert!(chunk.unwrap().is_ok());
}

/// Test error handling when provider fails
#[tokio::test]
async fn test_explain_vulnerability_stream_provider_error() {
    let provider = Arc::new(MockLlmProvider::new().with_error("Network timeout"));
    let config = create_test_config();
    let use_case = ExplainVulnerabilityUseCase::new(provider, config);

    let result = use_case
        .execute_stream("CVE-2021-44228", "Critical", "Description")
        .await;

    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Network timeout"));
}

/// Test that explanation model is used when configured
#[tokio::test]
async fn test_explain_vulnerability_uses_configured_model() {
    let response = create_streaming_response("Explanation text");
    let provider = Arc::new(MockLlmProvider::new().with_response(response));
    let config = create_test_config();
    let use_case = ExplainVulnerabilityUseCase::new(provider.clone(), config);

    let _ = use_case
        .execute_stream("CVE-001", "High", "Description")
        .await;

    let requests = provider.captured_requests.lock().await;
    assert_eq!(requests.len(), 1);
    assert_eq!(requests[0].model, "explanation-model");
}

/// Test that default model is used when explanation model is not set
#[tokio::test]
async fn test_explain_vulnerability_uses_default_model() {
    let response = create_streaming_response("Explanation text");
    let provider = Arc::new(MockLlmProvider::new().with_response(response));
    let mut config = create_test_config();
    config.explanation_model = None;
    let use_case = ExplainVulnerabilityUseCase::new(provider.clone(), config);

    let _ = use_case
        .execute_stream("CVE-001", "High", "Description")
        .await;

    let requests = provider.captured_requests.lock().await;
    assert_eq!(requests.len(), 1);
    assert_eq!(requests[0].model, "test-model");
}

/// Test that streaming is enabled in the request
#[tokio::test]
async fn test_explain_vulnerability_enables_streaming() {
    let response = create_streaming_response("Explanation");
    let provider = Arc::new(MockLlmProvider::new().with_response(response));
    let config = create_test_config();
    let use_case = ExplainVulnerabilityUseCase::new(provider.clone(), config);

    let _ = use_case
        .execute_stream("CVE-001", "Medium", "Desc")
        .await;

    let requests = provider.captured_requests.lock().await;
    assert_eq!(requests.len(), 1);
    assert_eq!(requests[0].stream, Some(true));
}

/// Test request contains finding details in the prompt
#[tokio::test]
async fn test_explain_vulnerability_includes_finding_details() {
    let response = create_streaming_response("Explanation");
    let provider = Arc::new(MockLlmProvider::new().with_response(response));
    let config = create_test_config();
    let use_case = ExplainVulnerabilityUseCase::new(provider.clone(), config);

    let _ = use_case
        .execute_stream(
            "CVE-2023-12345",
            "Critical",
            "Remote code execution via deserialization",
        )
        .await;

    let requests = provider.captured_requests.lock().await;
    assert_eq!(requests.len(), 1);

    let user_message = &requests[0].messages[0].content;
    assert!(user_message.contains("CVE-2023-12345"));
    assert!(user_message.contains("Critical"));
    assert!(user_message.contains("deserialization"));
}

/// Test various severity levels
#[tokio::test]
async fn test_explain_vulnerability_various_severities() {
    let severities = ["Critical", "High", "Medium", "Low", "Informational"];

    for severity in severities {
        let response = create_streaming_response(&format!("{} severity explanation", severity));
        let provider = Arc::new(MockLlmProvider::new().with_response(response));
        let config = create_test_config();
        let use_case = ExplainVulnerabilityUseCase::new(provider.clone(), config);

        let result = use_case
            .execute_stream("CVE-001", severity, "Test vulnerability")
            .await;

        assert!(result.is_ok(), "Failed for severity: {}", severity);

        let requests = provider.captured_requests.lock().await;
        assert!(requests[0].messages[0].content.contains(severity));
    }
}
